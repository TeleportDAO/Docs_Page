"use strict";(self.webpackChunkhot_gate_docs=self.webpackChunkhot_gate_docs||[]).push([[2131],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return f}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(r),f=a,d=p["".concat(c,".").concat(f)]||p[f]||h[f]||o;return r?n.createElement(d,i(i({ref:t},u),{},{components:r})):n.createElement(d,i({ref:t},u))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5136:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),i=["components"],s={sidebar_position:4},c="Relay",l={unversionedId:"Relay",id:"Relay",isDocsHomePage:!1,title:"Relay",description:"---",source:"@site/docs/Relay.md",sourceDirName:".",slug:"/Relay",permalink:"/whitepaper-docs/Relay",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"whitepaperSidebar",previous:{title:"Pools",permalink:"/whitepaper-docs/Pools"},next:{title:"Normal CC Settlement",permalink:"/whitepaper-docs/Cross-chain Settlement/Normal_CC_Settlement copy"}},u=[{value:"Introduction",id:"introduction",children:[]},{value:"Fees",id:"fees",children:[]},{value:"Buyback Mechanism",id:"buyback-mechanism",children:[]}],h={toc:u};function p(e){var t=e.components,r=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"relay"},"Relay"),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Relay is an interoperability solution that makes it possible to transfer assets and data from the source chain to the target chain. Relayers get block headers of the source chain and submit them on the target chain. Then relay, which is a smart contract on the target chain, checks the correctness of the submitted data. If a block header is validated by the relay, users can refer to it on the target chain for proving the validity of some data on the source chain. As block headers include Merkle roots of all transactions and states, the relay can perform state or transaction inclusion verifications using Merkle proofs generated by users."),(0,o.kt)("h2",{id:"fees"},"Fees"),(0,o.kt)("p",null,"Submitting and verifying block headers on the blockchain has a cost for relayers. To compensate relayers costs, relay takes fees from users. The fee covers the gas amount used for submitting and verifying block header, plus extra rewards for relayers. Relay users pay fees in the native token of the blockchain which is easier than paying the fees in other assets. The fee that a user needs to pay relay for verifying the inclusion of data depends on the total number of requests that are sent to relay in the previous epoch. For example, if the total number of requests in an epoch increase in comparison to the previous epoch, the fee that each user needs to pay will be decreased and vice versa. To avoid too much increase in the relay fee, we assume a base number for queries in the epoch. At the beginning of the relay deployment, a portion of total TDTs is transferred to it. When there are not enough requests for the relay, the relay uses these tokens to compensate relayers."),(0,o.kt)("h2",{id:"buyback-mechanism"},"Buyback Mechanism"),(0,o.kt)("p",null,"The relay pays relayers in TDT. For this purpose, the relay exchange the collected fees which are in the native token of the blockchain to TDT. The buyback mechanism happens periodically, which generates a demand for TDT."))}p.isMDXComponent=!0}}]);